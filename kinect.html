<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Kinect Point Cloud</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
  import { OrbitControls } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js';

  let camera, scene, renderer, controls;
  let video, videoTexture, mesh;

  init();
  animate();

  function init() {
    scene = new THREE.Scene();
    const width = window.innerWidth;
    const height = window.innerHeight;

    camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
    camera.position.z = 1000;

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(width, height);
    document.body.appendChild(renderer.domElement);

    video = document.createElement('video');
    video.src = 'textures/kinect.webm';
    video.loop = true;
    video.muted = true;
    video.play();

    videoTexture = new THREE.VideoTexture(video);
    videoTexture.minFilter = THREE.LinearFilter;
    videoTexture.magFilter = THREE.LinearFilter;
    videoTexture.format = THREE.RGBFormat;

    const amount = 512;
    const count = amount * amount;
    const positions = new Float32Array(count * 3);
    const uvs = new Float32Array(count * 2);

    let i = 0, j = 0;
    for (let y = 0; y < amount; y++) {
      for (let x = 0; x < amount; x++) {
        positions[i] = x - amount / 2;
        positions[i + 1] = -y + amount / 2;
        positions[i + 2] = 0;
        uvs[j] = x / amount;
        uvs[j + 1] = y / amount;
        i += 3;
        j += 2;
      }
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

    const material = new THREE.ShaderMaterial({
      uniforms: {
        map: { value: videoTexture }
      },
      vertexShader: `
        uniform sampler2D map;
        varying vec2 vUv;
        void main() {
          vUv = uv;
          vec4 color = texture2D(map, uv);
          vec3 pos = position;
          pos.z = color.r * 500.0;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform sampler2D map;
        void main() {
          gl_FragColor = texture2D(map, vUv);
        }
      `
    });

    mesh = new THREE.Points(geometry, material);
    scene.add(mesh);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.rotateSpeed = 0.5;

    window.addEventListener('resize', onWindowResize);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    if (video.readyState >= video.HAVE_CURRENT_DATA) {
      videoTexture.needsUpdate = true;
    }
    renderer.render(scene, camera);
  }
</script>
</body>
</html>
